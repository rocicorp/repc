#![allow(warnings)]

// automatically generated by the FlatBuffers compiler, do not modify

use std::cmp::Ordering;
use std::mem;

extern crate flatbuffers;
use self::flatbuffers::EndianScalar;

#[allow(unused_imports, dead_code)]
pub mod nodes {

    use std::cmp::Ordering;
    use std::mem;

    extern crate flatbuffers;
    use self::flatbuffers::EndianScalar;

    #[allow(non_camel_case_types)]
    #[repr(u8)]
    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
    pub enum Node {
        NONE = 0,
        Internal = 1,
        Leaf = 2,
        Data = 3,
    }

    pub const ENUM_MIN_NODE: u8 = 0;
    pub const ENUM_MAX_NODE: u8 = 3;

    impl<'a> flatbuffers::Follow<'a> for Node {
        type Inner = Self;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::read_scalar_at::<Self>(buf, loc)
        }
    }

    impl flatbuffers::EndianScalar for Node {
        #[inline]
        fn to_little_endian(self) -> Self {
            let n = u8::to_le(self as u8);
            let p = &n as *const u8 as *const Node;
            unsafe { *p }
        }
        #[inline]
        fn from_little_endian(self) -> Self {
            let n = u8::from_le(self as u8);
            let p = &n as *const u8 as *const Node;
            unsafe { *p }
        }
    }

    impl flatbuffers::Push for Node {
        type Output = Node;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            flatbuffers::emplace_scalar::<Node>(dst, *self);
        }
    }

    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_NODE: [Node; 4] = [Node::NONE, Node::Internal, Node::Leaf, Node::Data];

    #[allow(non_camel_case_types)]
    pub const ENUM_NAMES_NODE: [&'static str; 4] = ["NONE", "Internal", "Leaf", "Data"];

    pub fn enum_name_node(e: Node) -> &'static str {
        let index = e as u8;
        ENUM_NAMES_NODE[index as usize]
    }

    pub struct NodeUnionTableOffset {}
    pub enum InternalNodeOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct InternalNode<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for InternalNode<'a> {
        type Inner = InternalNode<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> InternalNode<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            InternalNode { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args InternalNodeArgs<'args>,
        ) -> flatbuffers::WIPOffset<InternalNode<'bldr>> {
            let mut builder = InternalNodeBuilder::new(_fbb);
            if let Some(x) = args.edges {
                builder.add_edges(x);
            }
            builder.finish()
        }

        pub const VT_EDGES: flatbuffers::VOffsetT = 4;

        #[inline]
        pub fn edges(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Edge<'a>>>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<flatbuffers::ForwardsUOffset<Edge<'a>>>,
            >>(InternalNode::VT_EDGES, None)
        }
    }

    pub struct InternalNodeArgs<'a> {
        pub edges: Option<
            flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Edge<'a>>>>,
        >,
    }
    impl<'a> Default for InternalNodeArgs<'a> {
        #[inline]
        fn default() -> Self {
            InternalNodeArgs { edges: None }
        }
    }
    pub struct InternalNodeBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> InternalNodeBuilder<'a, 'b> {
        #[inline]
        pub fn add_edges(
            &mut self,
            edges: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Edge<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(InternalNode::VT_EDGES, edges);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> InternalNodeBuilder<'a, 'b> {
            let start = _fbb.start_table();
            InternalNodeBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<InternalNode<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum EdgeOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct Edge<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Edge<'a> {
        type Inner = Edge<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> Edge<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Edge { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args EdgeArgs<'args>,
        ) -> flatbuffers::WIPOffset<Edge<'bldr>> {
            let mut builder = EdgeBuilder::new(_fbb);
            if let Some(x) = args.chunk_hash {
                builder.add_chunk_hash(x);
            }
            if let Some(x) = args.key {
                builder.add_key(x);
            }
            builder.finish()
        }

        pub const VT_KEY: flatbuffers::VOffsetT = 4;
        pub const VT_CHUNK_HASH: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn key(&self) -> Option<&'a [u8]> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    Edge::VT_KEY,
                    None,
                )
                .map(|v| v.safe_slice())
        }
        #[inline]
        pub fn chunk_hash(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Edge::VT_CHUNK_HASH, None)
        }
    }

    pub struct EdgeArgs<'a> {
        pub key: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub chunk_hash: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for EdgeArgs<'a> {
        #[inline]
        fn default() -> Self {
            EdgeArgs {
                key: None,
                chunk_hash: None,
            }
        }
    }
    pub struct EdgeBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> EdgeBuilder<'a, 'b> {
        #[inline]
        pub fn add_key(&mut self, key: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Edge::VT_KEY, key);
        }
        #[inline]
        pub fn add_chunk_hash(&mut self, chunk_hash: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Edge::VT_CHUNK_HASH, chunk_hash);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> EdgeBuilder<'a, 'b> {
            let start = _fbb.start_table();
            EdgeBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Edge<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum DataNodeOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct DataNode<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for DataNode<'a> {
        type Inner = DataNode<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> DataNode<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            DataNode { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args DataNodeArgs<'args>,
        ) -> flatbuffers::WIPOffset<DataNode<'bldr>> {
            let mut builder = DataNodeBuilder::new(_fbb);
            if let Some(x) = args.entries {
                builder.add_entries(x);
            }
            builder.finish()
        }

        pub const VT_ENTRIES: flatbuffers::VOffsetT = 4;

        #[inline]
        pub fn entries(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DataNodeEntry<'a>>>>
        {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<flatbuffers::ForwardsUOffset<DataNodeEntry<'a>>>,
            >>(DataNode::VT_ENTRIES, None)
        }
    }

    pub struct DataNodeArgs<'a> {
        pub entries: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DataNodeEntry<'a>>>,
            >,
        >,
    }
    impl<'a> Default for DataNodeArgs<'a> {
        #[inline]
        fn default() -> Self {
            DataNodeArgs { entries: None }
        }
    }
    pub struct DataNodeBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> DataNodeBuilder<'a, 'b> {
        #[inline]
        pub fn add_entries(
            &mut self,
            entries: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<DataNodeEntry<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(DataNode::VT_ENTRIES, entries);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DataNodeBuilder<'a, 'b> {
            let start = _fbb.start_table();
            DataNodeBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<DataNode<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum DataNodeEntryOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct DataNodeEntry<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for DataNodeEntry<'a> {
        type Inner = DataNodeEntry<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> DataNodeEntry<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            DataNodeEntry { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args DataNodeEntryArgs<'args>,
        ) -> flatbuffers::WIPOffset<DataNodeEntry<'bldr>> {
            let mut builder = DataNodeEntryBuilder::new(_fbb);
            if let Some(x) = args.value {
                builder.add_value(x);
            }
            if let Some(x) = args.key {
                builder.add_key(x);
            }
            builder.finish()
        }

        pub const VT_KEY: flatbuffers::VOffsetT = 4;
        pub const VT_VALUE: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn key(&self) -> Option<&'a [u8]> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    DataNodeEntry::VT_KEY,
                    None,
                )
                .map(|v| v.safe_slice())
        }
        #[inline]
        pub fn value(&self) -> Option<&'a [u8]> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    DataNodeEntry::VT_VALUE,
                    None,
                )
                .map(|v| v.safe_slice())
        }
    }

    pub struct DataNodeEntryArgs<'a> {
        pub key: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for DataNodeEntryArgs<'a> {
        #[inline]
        fn default() -> Self {
            DataNodeEntryArgs {
                key: None,
                value: None,
            }
        }
    }
    pub struct DataNodeEntryBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> DataNodeEntryBuilder<'a, 'b> {
        #[inline]
        pub fn add_key(&mut self, key: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(DataNodeEntry::VT_KEY, key);
        }
        #[inline]
        pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(DataNodeEntry::VT_VALUE, value);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> DataNodeEntryBuilder<'a, 'b> {
            let start = _fbb.start_table();
            DataNodeEntryBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<DataNodeEntry<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum NodeRecordOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct NodeRecord<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for NodeRecord<'a> {
        type Inner = NodeRecord<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> NodeRecord<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            NodeRecord { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args NodeRecordArgs,
        ) -> flatbuffers::WIPOffset<NodeRecord<'bldr>> {
            let mut builder = NodeRecordBuilder::new(_fbb);
            if let Some(x) = args.record {
                builder.add_record(x);
            }
            builder.add_record_type(args.record_type);
            builder.finish()
        }

        pub const VT_RECORD_TYPE: flatbuffers::VOffsetT = 4;
        pub const VT_RECORD: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn record_type(&self) -> Node {
            self._tab
                .get::<Node>(NodeRecord::VT_RECORD_TYPE, Some(Node::NONE))
                .unwrap()
        }
        #[inline]
        pub fn record(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    NodeRecord::VT_RECORD,
                    None,
                )
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn record_as_internal(&self) -> Option<InternalNode<'a>> {
            if self.record_type() == Node::Internal {
                self.record().map(|u| InternalNode::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn record_as_leaf(&self) -> Option<InternalNode<'a>> {
            if self.record_type() == Node::Leaf {
                self.record().map(|u| InternalNode::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn record_as_data(&self) -> Option<DataNode<'a>> {
            if self.record_type() == Node::Data {
                self.record().map(|u| DataNode::init_from_table(u))
            } else {
                None
            }
        }
    }

    pub struct NodeRecordArgs {
        pub record_type: Node,
        pub record: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for NodeRecordArgs {
        #[inline]
        fn default() -> Self {
            NodeRecordArgs {
                record_type: Node::NONE,
                record: None,
            }
        }
    }
    pub struct NodeRecordBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> NodeRecordBuilder<'a, 'b> {
        #[inline]
        pub fn add_record_type(&mut self, record_type: Node) {
            self.fbb_
                .push_slot::<Node>(NodeRecord::VT_RECORD_TYPE, record_type, Node::NONE);
        }
        #[inline]
        pub fn add_record(&mut self, record: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(NodeRecord::VT_RECORD, record);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> NodeRecordBuilder<'a, 'b> {
            let start = _fbb.start_table();
            NodeRecordBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<NodeRecord<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    #[inline]
    pub fn get_root_as_node_record<'a>(buf: &'a [u8]) -> NodeRecord<'a> {
        flatbuffers::get_root::<NodeRecord<'a>>(buf)
    }

    #[inline]
    pub fn get_size_prefixed_root_as_node_record<'a>(buf: &'a [u8]) -> NodeRecord<'a> {
        flatbuffers::get_size_prefixed_root::<NodeRecord<'a>>(buf)
    }

    #[inline]
    pub fn finish_node_record_buffer<'a, 'b>(
        fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        root: flatbuffers::WIPOffset<NodeRecord<'a>>,
    ) {
        fbb.finish(root, None);
    }

    #[inline]
    pub fn finish_size_prefixed_node_record_buffer<'a, 'b>(
        fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        root: flatbuffers::WIPOffset<NodeRecord<'a>>,
    ) {
        fbb.finish_size_prefixed(root, None);
    }
} // pub mod nodes
